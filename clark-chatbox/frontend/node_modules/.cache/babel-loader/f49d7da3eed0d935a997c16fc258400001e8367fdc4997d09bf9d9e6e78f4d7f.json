{"ast":null,"code":"import { io } from 'socket.io-client';\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\nclass SocketService {\n  constructor() {\n    this.socket = null;\n    this.userId = null;\n    this.sessionId = null;\n    this.userType = 'student';\n    this.messageListeners = [];\n  }\n  connect(userType) {\n    if (this.socket) return;\n    this.socket = io(BACKEND_URL);\n    this.userType = userType;\n    this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\n    this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\n\n    // Store IDs for persistence\n    localStorage.setItem('userId', this.userId);\n    localStorage.setItem('sessionId', this.sessionId);\n    this.socket.on('message:receive', message => {\n      // Convert timestamp to Date object if it's a string\n      if (typeof message.timestamp === 'string') {\n        message.timestamp = new Date(message.timestamp);\n      }\n      this.messageListeners.forEach(listener => listener(message));\n    });\n    this.socket.on('disconnect', () => {\n      console.log('Disconnected from server');\n    });\n    this.socket.on('connect', () => {\n      console.log('Connected to server');\n    });\n    this.socket.on('connect_error', error => {\n      console.error('Connection error:', error);\n    });\n  }\n  sendMessage(text) {\n    return new Promise((resolve, reject) => {\n      if (!this.socket) {\n        reject(new Error('Socket not connected'));\n        return;\n      }\n      this.socket.emit('message:send', {\n        text,\n        userId: this.userId,\n        userType: this.userType,\n        sessionId: this.sessionId\n      });\n      resolve();\n    });\n  }\n  onMessage(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n  getChatHistory() {\n    return new Promise((resolve, reject) => {\n      if (!this.socket) {\n        reject(new Error('Socket not connected'));\n        return;\n      }\n      this.socket.emit('chat:history', {\n        userId: this.userId,\n        sessionId: this.sessionId\n      });\n      this.socket.once('chat:history', history => {\n        // Convert timestamps to Date objects\n        const processedHistory = history.map(msg => ({\n          ...msg,\n          timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp\n        }));\n        resolve(processedHistory);\n      });\n      this.socket.once('chat:error', error => {\n        reject(new Error(error.message || 'Failed to get chat history'));\n      });\n\n      // Set a timeout in case the server doesn't respond\n      setTimeout(() => {\n        reject(new Error('Timeout getting chat history'));\n      }, 5000);\n    });\n  }\n\n  // Check if socket is connected\n  isConnected() {\n    var _this$socket;\n    return ((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.connected) || false;\n  }\n}\nexport default new SocketService();","map":{"version":3,"names":["io","BACKEND_URL","process","env","REACT_APP_BACKEND_URL","SocketService","constructor","socket","userId","sessionId","userType","messageListeners","connect","localStorage","getItem","Date","now","setItem","on","message","timestamp","forEach","listener","console","log","error","sendMessage","text","Promise","resolve","reject","Error","emit","onMessage","callback","push","filter","cb","disconnect","getChatHistory","once","history","processedHistory","map","msg","setTimeout","isConnected","_this$socket","connected"],"sources":["C:/Users/haris/clark-guide/clark-chatbox/frontend/src/services/socketService.ts"],"sourcesContent":["import { io, Socket } from 'socket.io-client';\r\nimport { UserType } from '../contexts/UserContext';\r\n\r\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\r\n\r\nexport interface ChatMessage {\r\n  id?: string | number;\r\n  text: string;\r\n  sender: 'user' | 'ai';\r\n  timestamp: Date;\r\n  metadata?: any;\r\n}\r\n\r\nclass SocketService {\r\n  private socket: Socket | null = null;\r\n  private userId: string | null = null;\r\n  private sessionId: string | null = null;\r\n  private userType: UserType = 'student';\r\n  private messageListeners: Array<(message: ChatMessage) => void> = [];\r\n  \r\n  connect(userType: UserType) {\r\n    if (this.socket) return;\r\n    \r\n    this.socket = io(BACKEND_URL);\r\n    this.userType = userType;\r\n    this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\r\n    this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\r\n    \r\n    // Store IDs for persistence\r\n    localStorage.setItem('userId', this.userId);\r\n    localStorage.setItem('sessionId', this.sessionId);\r\n    \r\n    this.socket.on('message:receive', (message: ChatMessage) => {\r\n      // Convert timestamp to Date object if it's a string\r\n      if (typeof message.timestamp === 'string') {\r\n        message.timestamp = new Date(message.timestamp);\r\n      }\r\n      \r\n      this.messageListeners.forEach(listener => listener(message));\r\n    });\r\n    \r\n    this.socket.on('disconnect', () => {\r\n      console.log('Disconnected from server');\r\n    });\r\n    \r\n    this.socket.on('connect', () => {\r\n      console.log('Connected to server');\r\n    });\r\n    \r\n    this.socket.on('connect_error', (error) => {\r\n      console.error('Connection error:', error);\r\n    });\r\n  }\r\n  \r\n  sendMessage(text: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket) {\r\n        reject(new Error('Socket not connected'));\r\n        return;\r\n      }\r\n      \r\n      this.socket.emit('message:send', {\r\n        text,\r\n        userId: this.userId,\r\n        userType: this.userType,\r\n        sessionId: this.sessionId\r\n      });\r\n      \r\n      resolve();\r\n    });\r\n  }\r\n  \r\n  onMessage(callback: (message: ChatMessage) => void) {\r\n    this.messageListeners.push(callback);\r\n    return () => {\r\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\r\n    };\r\n  }\r\n  \r\n  disconnect() {\r\n    if (this.socket) {\r\n      this.socket.disconnect();\r\n      this.socket = null;\r\n    }\r\n  }\r\n  \r\n  getChatHistory(): Promise<ChatMessage[]> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket) {\r\n        reject(new Error('Socket not connected'));\r\n        return;\r\n      }\r\n      \r\n      this.socket.emit('chat:history', {\r\n        userId: this.userId,\r\n        sessionId: this.sessionId\r\n      });\r\n      \r\n      this.socket.once('chat:history', (history: ChatMessage[]) => {\r\n        // Convert timestamps to Date objects\r\n        const processedHistory = history.map(msg => ({\r\n          ...msg,\r\n          timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp\r\n        }));\r\n        resolve(processedHistory);\r\n      });\r\n      \r\n      this.socket.once('chat:error', (error) => {\r\n        reject(new Error(error.message || 'Failed to get chat history'));\r\n      });\r\n      \r\n      // Set a timeout in case the server doesn't respond\r\n      setTimeout(() => {\r\n        reject(new Error('Timeout getting chat history'));\r\n      }, 5000);\r\n    });\r\n  }\r\n  \r\n  // Check if socket is connected\r\n  isConnected(): boolean {\r\n    return this.socket?.connected || false;\r\n  }\r\n}\r\n\r\nexport default new SocketService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}