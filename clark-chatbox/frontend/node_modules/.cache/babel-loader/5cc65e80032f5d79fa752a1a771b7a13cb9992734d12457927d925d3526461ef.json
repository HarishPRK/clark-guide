{"ast":null,"code":"var _SocketService;\nimport { io } from 'socket.io-client';\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\n// Singleton instance to ensure only one socket connection\nclass SocketService {\n  // Flag to prevent multiple simultaneous connection attempts\n\n  // Private constructor for singleton\n  constructor() {\n    // Singleton instance\n    this.socket = null;\n    this.userId = null;\n    this.sessionId = null;\n    this.userType = 'student';\n    this.messageListeners = [];\n    this.processedMessages = new Set();\n    // Track message IDs we've already processed\n    this.connecting = false;\n    console.log('SocketService instance created');\n    // Initialize userId and sessionId from localStorage if available\n    this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\n    this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\n\n    // Store IDs for persistence\n    localStorage.setItem('userId', this.userId);\n    localStorage.setItem('sessionId', this.sessionId);\n  }\n\n  // Get singleton instance\n  static getInstance() {\n    if (!SocketService.instance) {\n      SocketService.instance = new SocketService();\n    }\n    return SocketService.instance;\n  }\n  connect(userType) {\n    return new Promise((resolve, reject) => {\n      // If already connected, just resolve\n      if (this.socket && this.socket.connected) {\n        console.log('Socket already connected, reusing connection');\n        this.userType = userType; // Update userType\n        resolve(true);\n        return;\n      }\n\n      // If currently trying to connect, wait\n      if (this.connecting) {\n        console.log('Connection attempt already in progress');\n        setTimeout(() => {\n          if (this.socket && this.socket.connected) {\n            resolve(true);\n          } else {\n            reject(new Error('Connection in progress timed out'));\n          }\n        }, 5000);\n        return;\n      }\n      this.connecting = true;\n      console.log('Starting new socket connection');\n\n      // Disconnect existing socket if any\n      if (this.socket) {\n        console.log('Disconnecting existing socket');\n        this.socket.disconnect();\n        this.socket = null;\n      }\n      console.log('Connecting to socket server at:', BACKEND_URL);\n      this.socket = io(BACKEND_URL, {\n        transports: ['websocket', 'polling'],\n        reconnectionAttempts: 5,\n        timeout: 10000\n      });\n      this.userType = userType;\n\n      // Set up connection timeout\n      const connectionTimeout = setTimeout(() => {\n        console.error('Connection timeout');\n        this.connecting = false;\n        reject(new Error('Connection timeout'));\n      }, 10000);\n      this.socket.on('connect', () => {\n        var _this$socket;\n        console.log('Successfully connected to server with socket ID:', (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.id);\n        clearTimeout(connectionTimeout);\n        this.connecting = false;\n        resolve(true);\n      });\n      this.socket.on('message:receive', message => {\n        console.log('Received message:', message);\n\n        // Generate a message key for deduplication\n        const messageKey = message.requestId || (message.id ? message.id.toString() : `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`);\n\n        // Check if we've already processed this message\n        if (this.processedMessages.has(messageKey)) {\n          console.log(`Skipping duplicate message with ID: ${messageKey}`);\n          return;\n        }\n\n        // Mark this message as processed\n        this.processedMessages.add(messageKey);\n\n        // Limit the size of the processed messages set to avoid memory leaks\n        if (this.processedMessages.size > 100) {\n          // Remove the oldest items (first 50) when we hit the limit\n          const iterator = this.processedMessages.values();\n          for (let i = 0; i < 50; i++) {\n            const value = iterator.next().value;\n            if (value) this.processedMessages.delete(value);\n          }\n        }\n\n        // Convert timestamp to Date object if it's a string\n        if (typeof message.timestamp === 'string') {\n          message.timestamp = new Date(message.timestamp);\n        }\n\n        // Notify all listeners\n        this.messageListeners.forEach(listener => listener(message));\n      });\n      this.socket.on('disconnect', () => {\n        console.log('Disconnected from server');\n        this.connecting = false;\n      });\n      this.socket.on('connect_error', error => {\n        console.error('Connection error:', error);\n        clearTimeout(connectionTimeout);\n        this.connecting = false;\n        reject(error);\n      });\n    });\n  }\n  sendMessage(text) {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.socket.connected) {\n        console.error('Socket not connected');\n        reject(new Error('Socket not connected. Please refresh and try again.'));\n        return;\n      }\n      const messageData = {\n        text,\n        userId: this.userId,\n        userType: this.userType,\n        sessionId: this.sessionId\n      };\n      console.log('Sending message:', messageData);\n\n      // Set up a timeout in case the server doesn't respond\n      // const messageTimeout = setTimeout(() => {\n      //   console.error('Message sending timeout');\n      //   reject(new Error('Server did not respond. Please try again later.'));\n      // }, 15000);\n\n      // Send the message\n      this.socket.emit('message:send', messageData, () => {\n        clearTimeout(messageTimeout);\n        resolve();\n      });\n    });\n  }\n  onMessage(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n  disconnect() {\n    if (this.socket) {\n      console.log('Manually disconnecting socket');\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n  getChatHistory() {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.socket.connected) {\n        console.error('Socket not connected');\n        resolve([]); // Return empty array instead of rejecting for better UX\n        return;\n      }\n      console.log('Requesting chat history for:', this.userId, this.sessionId);\n\n      // Set a timeout in case the server doesn't respond\n      const historyTimeout = setTimeout(() => {\n        console.error('Chat history timeout');\n        resolve([]); // Return empty array on timeout\n      }, 8000);\n      this.socket.emit('chat:history', {\n        userId: this.userId,\n        sessionId: this.sessionId\n      });\n      this.socket.once('chat:history', history => {\n        console.log('Received chat history:', history);\n        clearTimeout(historyTimeout);\n\n        // Check if history is valid\n        if (!Array.isArray(history)) {\n          console.error('Invalid chat history format:', history);\n          resolve([]);\n          return;\n        }\n\n        // Convert timestamps to Date objects\n        const processedHistory = history.map(msg => ({\n          ...msg,\n          timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp\n        }));\n        resolve(processedHistory);\n      });\n      this.socket.once('chat:error', error => {\n        console.error('Chat history error:', error);\n        clearTimeout(historyTimeout);\n        resolve([]); // Return empty array instead of rejecting\n      });\n    });\n  }\n\n  // Check if socket is connected\n  isConnected() {\n    var _this$socket2;\n    return ((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.connected) || false;\n  }\n\n  // Get socket ID for debugging\n  getSocketId() {\n    var _this$socket3;\n    return ((_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.id) || null;\n  }\n}\n\n// Export the singleton instance\n_SocketService = SocketService;\nSocketService.instance = void 0;\nexport default SocketService.getInstance();","map":{"version":3,"names":["io","BACKEND_URL","process","env","REACT_APP_BACKEND_URL","SocketService","constructor","socket","userId","sessionId","userType","messageListeners","processedMessages","Set","connecting","console","log","localStorage","getItem","Date","now","setItem","getInstance","instance","connect","Promise","resolve","reject","connected","setTimeout","Error","disconnect","transports","reconnectionAttempts","timeout","connectionTimeout","error","on","_this$socket","id","clearTimeout","message","messageKey","requestId","toString","Math","random","substring","has","add","size","iterator","values","i","value","next","delete","timestamp","forEach","listener","sendMessage","text","messageData","emit","messageTimeout","onMessage","callback","push","filter","cb","getChatHistory","historyTimeout","once","history","Array","isArray","processedHistory","map","msg","isConnected","_this$socket2","getSocketId","_this$socket3","_SocketService"],"sources":["C:/Users/haris/clark-guide/clark-chatbox/frontend/src/services/socketService.ts"],"sourcesContent":["import { io, Socket } from 'socket.io-client';\r\nimport { UserType } from '../contexts/UserContext';\r\n\r\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\r\n\r\nexport interface ChatMessage {\r\n  id?: string | number;\r\n  text: string;\r\n  sender: 'user' | 'ai';\r\n  timestamp: Date;\r\n  metadata?: any;\r\n}\r\n\r\n// Singleton instance to ensure only one socket connection\r\nclass SocketService {\r\n  private static instance: SocketService; // Singleton instance\r\n  private socket: Socket | null = null;\r\n  private userId: string | null = null;\r\n  private sessionId: string | null = null;\r\n  private userType: UserType = 'student';\r\n  private messageListeners: Array<(message: ChatMessage) => void> = [];\r\n  private processedMessages = new Set<string>(); // Track message IDs we've already processed\r\n  private connecting = false; // Flag to prevent multiple simultaneous connection attempts\r\n  \r\n  // Private constructor for singleton\r\n  private constructor() {\r\n    console.log('SocketService instance created');\r\n    // Initialize userId and sessionId from localStorage if available\r\n    this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\r\n    this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\r\n    \r\n    // Store IDs for persistence\r\n    localStorage.setItem('userId', this.userId);\r\n    localStorage.setItem('sessionId', this.sessionId);\r\n  }\r\n  \r\n  // Get singleton instance\r\n  public static getInstance(): SocketService {\r\n    if (!SocketService.instance) {\r\n      SocketService.instance = new SocketService();\r\n    }\r\n    return SocketService.instance;\r\n  }\r\n  \r\n  connect(userType: UserType): Promise<boolean> {\r\n    return new Promise((resolve, reject) => {\r\n      // If already connected, just resolve\r\n      if (this.socket && this.socket.connected) {\r\n        console.log('Socket already connected, reusing connection');\r\n        this.userType = userType; // Update userType\r\n        resolve(true);\r\n        return;\r\n      }\r\n      \r\n      // If currently trying to connect, wait\r\n      if (this.connecting) {\r\n        console.log('Connection attempt already in progress');\r\n        setTimeout(() => {\r\n          if (this.socket && this.socket.connected) {\r\n            resolve(true);\r\n          } else {\r\n            reject(new Error('Connection in progress timed out'));\r\n          }\r\n        }, 5000);\r\n        return;\r\n      }\r\n      \r\n      this.connecting = true;\r\n      console.log('Starting new socket connection');\r\n      \r\n      // Disconnect existing socket if any\r\n      if (this.socket) {\r\n        console.log('Disconnecting existing socket');\r\n        this.socket.disconnect();\r\n        this.socket = null;\r\n      }\r\n      \r\n      console.log('Connecting to socket server at:', BACKEND_URL);\r\n      this.socket = io(BACKEND_URL, {\r\n        transports: ['websocket', 'polling'],\r\n        reconnectionAttempts: 5,\r\n        timeout: 10000\r\n      });\r\n      \r\n      this.userType = userType;\r\n      \r\n      // Set up connection timeout\r\n      const connectionTimeout = setTimeout(() => {\r\n        console.error('Connection timeout');\r\n        this.connecting = false;\r\n        reject(new Error('Connection timeout'));\r\n      }, 10000);\r\n      \r\n      this.socket.on('connect', () => {\r\n        console.log('Successfully connected to server with socket ID:', this.socket?.id);\r\n        clearTimeout(connectionTimeout);\r\n        this.connecting = false;\r\n        resolve(true);\r\n      });\r\n      \r\n      this.socket.on('message:receive', (message: ChatMessage & { requestId?: string }) => {\r\n        console.log('Received message:', message);\r\n        \r\n        // Generate a message key for deduplication\r\n        const messageKey = message.requestId || \r\n                          (message.id ? message.id.toString() : \r\n                          `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`);\r\n        \r\n        // Check if we've already processed this message\r\n        if (this.processedMessages.has(messageKey)) {\r\n          console.log(`Skipping duplicate message with ID: ${messageKey}`);\r\n          return;\r\n        }\r\n        \r\n        // Mark this message as processed\r\n        this.processedMessages.add(messageKey);\r\n        \r\n        // Limit the size of the processed messages set to avoid memory leaks\r\n        if (this.processedMessages.size > 100) {\r\n          // Remove the oldest items (first 50) when we hit the limit\r\n          const iterator = this.processedMessages.values();\r\n          for (let i = 0; i < 50; i++) {\r\n            const value = iterator.next().value;\r\n            if (value) this.processedMessages.delete(value);\r\n          }\r\n        }\r\n        \r\n        // Convert timestamp to Date object if it's a string\r\n        if (typeof message.timestamp === 'string') {\r\n          message.timestamp = new Date(message.timestamp);\r\n        }\r\n        \r\n        // Notify all listeners\r\n        this.messageListeners.forEach(listener => listener(message));\r\n      });\r\n      \r\n      this.socket.on('disconnect', () => {\r\n        console.log('Disconnected from server');\r\n        this.connecting = false;\r\n      });\r\n      \r\n      this.socket.on('connect_error', (error) => {\r\n        console.error('Connection error:', error);\r\n        clearTimeout(connectionTimeout);\r\n        this.connecting = false;\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n  \r\n  sendMessage(text: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || !this.socket.connected) {\r\n        console.error('Socket not connected');\r\n        reject(new Error('Socket not connected. Please refresh and try again.'));\r\n        return;\r\n      }\r\n      \r\n      const messageData = {\r\n        text,\r\n        userId: this.userId,\r\n        userType: this.userType,\r\n        sessionId: this.sessionId\r\n      };\r\n      \r\n      console.log('Sending message:', messageData);\r\n      \r\n      // Set up a timeout in case the server doesn't respond\r\n      // const messageTimeout = setTimeout(() => {\r\n      //   console.error('Message sending timeout');\r\n      //   reject(new Error('Server did not respond. Please try again later.'));\r\n      // }, 15000);\r\n      \r\n      // Send the message\r\n      this.socket.emit('message:send', messageData, () => {\r\n        clearTimeout(messageTimeout);\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n  \r\n  onMessage(callback: (message: ChatMessage) => void) {\r\n    this.messageListeners.push(callback);\r\n    return () => {\r\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\r\n    };\r\n  }\r\n  \r\n  disconnect() {\r\n    if (this.socket) {\r\n      console.log('Manually disconnecting socket');\r\n      this.socket.disconnect();\r\n      this.socket = null;\r\n    }\r\n  }\r\n  \r\n  getChatHistory(): Promise<ChatMessage[]> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || !this.socket.connected) {\r\n        console.error('Socket not connected');\r\n        resolve([]); // Return empty array instead of rejecting for better UX\r\n        return;\r\n      }\r\n      \r\n      console.log('Requesting chat history for:', this.userId, this.sessionId);\r\n      \r\n      // Set a timeout in case the server doesn't respond\r\n      const historyTimeout = setTimeout(() => {\r\n        console.error('Chat history timeout');\r\n        resolve([]); // Return empty array on timeout\r\n      }, 8000);\r\n      \r\n      this.socket.emit('chat:history', {\r\n        userId: this.userId,\r\n        sessionId: this.sessionId\r\n      });\r\n      \r\n      this.socket.once('chat:history', (history: ChatMessage[]) => {\r\n        console.log('Received chat history:', history);\r\n        clearTimeout(historyTimeout);\r\n        \r\n        // Check if history is valid\r\n        if (!Array.isArray(history)) {\r\n          console.error('Invalid chat history format:', history);\r\n          resolve([]);\r\n          return;\r\n        }\r\n        \r\n        // Convert timestamps to Date objects\r\n        const processedHistory = history.map(msg => ({\r\n          ...msg,\r\n          timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp\r\n        }));\r\n        resolve(processedHistory);\r\n      });\r\n      \r\n      this.socket.once('chat:error', (error) => {\r\n        console.error('Chat history error:', error);\r\n        clearTimeout(historyTimeout);\r\n        resolve([]); // Return empty array instead of rejecting\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Check if socket is connected\r\n  isConnected(): boolean {\r\n    return this.socket?.connected || false;\r\n  }\r\n  \r\n  // Get socket ID for debugging\r\n  getSocketId(): string | null {\r\n    return this.socket?.id || null;\r\n  }\r\n}\r\n\r\n// Export the singleton instance\r\nexport default SocketService.getInstance();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}