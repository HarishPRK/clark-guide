{"ast":null,"code":"var _SocketService;\nimport { io } from 'socket.io-client';\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\n// Singleton instance to ensure only one socket connection\nclass SocketService {\n  // Flag to prevent multiple simultaneous connection attempts\n\n  // Private constructor for singleton\n  constructor() {\n    // Singleton instance\n    this.socket = null;\n    this.userId = null;\n    this.sessionId = null;\n    this.userType = 'student';\n    this.messageListeners = [];\n    this.processedMessages = new Set();\n    // Track message IDs we've already processed\n    this.connecting = false;\n    console.log('SocketService instance created');\n    // Initialize userId and sessionId from localStorage if available\n    this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\n    this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\n\n    // Store IDs for persistence\n    localStorage.setItem('userId', this.userId);\n    localStorage.setItem('sessionId', this.sessionId);\n  }\n\n  // Get singleton instance\n  static getInstance() {\n    if (!SocketService.instance) {\n      SocketService.instance = new SocketService();\n    }\n    return SocketService.instance;\n  }\n  connect(userType) {\n    return new Promise((resolve, reject) => {\n      // If already connected, just resolve\n      if (this.socket && this.socket.connected) {\n        console.log('Socket already connected, reusing connection');\n        this.userType = userType; // Update userType\n        resolve(true);\n        return;\n      }\n\n      // If currently trying to connect, wait\n      if (this.connecting) {\n        console.log('Connection attempt already in progress');\n        setTimeout(() => {\n          if (this.socket && this.socket.connected) {\n            resolve(true);\n          } else {\n            reject(new Error('Connection in progress timed out'));\n          }\n        }, 5000);\n        return;\n      }\n      this.connecting = true;\n      console.log('Starting new socket connection');\n\n      // Disconnect existing socket if any\n      if (this.socket) {\n        console.log('Disconnecting existing socket');\n        this.socket.disconnect();\n        this.socket = null;\n      }\n      console.log('Connecting to socket server at:', BACKEND_URL);\n      this.socket = io(BACKEND_URL, {\n        transports: ['websocket', 'polling'],\n        reconnectionAttempts: 5,\n        timeout: 10000\n      });\n      this.userType = userType;\n\n      // Set up connection timeout\n      const connectionTimeout = setTimeout(() => {\n        console.error('Connection timeout');\n        this.connecting = false;\n        reject(new Error('Connection timeout'));\n      }, 10000);\n      this.socket.on('connect', () => {\n        var _this$socket;\n        console.log('Successfully connected to server with socket ID:', (_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.id);\n        clearTimeout(connectionTimeout);\n        this.connecting = false;\n        resolve(true);\n      });\n      this.socket.on('message:receive', message => {\n        var _message$metadata, _message$metadata2, _message$metadata3;\n        console.log('Received message:', message);\n\n        // Generate a message key for deduplication\n        const messageKey = message.requestId || (message.id ? message.id.toString() : `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`);\n\n        // Check if we've already processed this message\n        if (this.processedMessages.has(messageKey)) {\n          console.log(`Skipping duplicate message with ID: ${messageKey}`);\n          return;\n        }\n\n        // Mark this message as processed\n        this.processedMessages.add(messageKey);\n\n        // Limit the size of the processed messages set to avoid memory leaks\n        if (this.processedMessages.size > 100) {\n          // Remove the oldest items (first 50) when we hit the limit\n          const iterator = this.processedMessages.values();\n          for (let i = 0; i < 50; i++) {\n            const value = iterator.next().value;\n            if (value) this.processedMessages.delete(value);\n          }\n        }\n\n        // Convert timestamp to Date object if it's a string\n        if (typeof message.timestamp === 'string') {\n          message.timestamp = new Date(message.timestamp);\n        }\n\n        // Transfer special properties from the received message or its metadata\n        const enhancedMessage = {\n          ...message,\n          // Ensure these properties are directly exposed at the message level\n          showCalendar: message.showCalendar || ((_message$metadata = message.metadata) === null || _message$metadata === void 0 ? void 0 : _message$metadata.showCalendar) || false,\n          selectedDate: message.selectedDate || ((_message$metadata2 = message.metadata) === null || _message$metadata2 === void 0 ? void 0 : _message$metadata2.selectedDate),\n          availableTimes: message.availableTimes || ((_message$metadata3 = message.metadata) === null || _message$metadata3 === void 0 ? void 0 : _message$metadata3.availableTimes)\n        };\n\n        // Check for specific keywords in text that would indicate calendar needs\n        if (enhancedMessage.sender === 'ai' && !enhancedMessage.showCalendar) {\n          const lowerText = enhancedMessage.text.toLowerCase();\n\n          // Check if message suggests selecting a different date\n          if (lowerText.includes('no rooms available') && lowerText.includes('different date') || lowerText.includes('try a different date') || lowerText.includes('select a date') || lowerText.includes('what date would you like')) {\n            console.log('Auto-enabling calendar based on message content');\n            enhancedMessage.showCalendar = true;\n          }\n\n          // Check if message is asking for time selection\n          if (lowerText.includes('what time would you like') || lowerText.includes('select a time') || lowerText.includes('select from the available') || lowerText.includes('time slots') || lowerText.includes('available slots')) {\n            console.log('Detected time selection request');\n\n            // Find the last user message that might have a date\n            const lastUserMsg = this.findLastUserMessageWithDate();\n            if (lastUserMsg) {\n              console.log('Found date from previous message:', lastUserMsg.selectedDate);\n              enhancedMessage.selectedDate = lastUserMsg.selectedDate;\n\n              // If we don't have availableTimes in the metadata, create some default ones\n              if (!enhancedMessage.availableTimes || enhancedMessage.availableTimes.length === 0) {\n                console.log('No time slots in metadata, creating default ones');\n                enhancedMessage.availableTimes = [{\n                  start: '09:00',\n                  end: '10:00'\n                }, {\n                  start: '11:00',\n                  end: '12:00'\n                }, {\n                  start: '13:30',\n                  end: '14:30'\n                }, {\n                  start: '15:00',\n                  end: '16:00'\n                }, {\n                  start: '17:30',\n                  end: '18:30'\n                }];\n              }\n            }\n          }\n        }\n\n        // Notify all listeners with the enhanced message\n        this.messageListeners.forEach(listener => listener(enhancedMessage));\n      });\n      this.socket.on('disconnect', () => {\n        console.log('Disconnected from server');\n        this.connecting = false;\n      });\n      this.socket.on('connect_error', error => {\n        console.error('Connection error:', error);\n        clearTimeout(connectionTimeout);\n        this.connecting = false;\n        reject(error);\n      });\n    });\n  }\n  sendMessage(text) {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.socket.connected) {\n        console.error('Socket not connected');\n        reject(new Error('Socket not connected. Please refresh and try again.'));\n        return;\n      }\n      const messageData = {\n        text,\n        userId: this.userId,\n        userType: this.userType,\n        sessionId: this.sessionId\n      };\n      console.log('Sending message:', messageData);\n\n      // Just emit the message and resolve immediately - no need to wait for acknowledgment\n      // The actual response will come through the message:receive event handler\n      this.socket.emit('message:send', messageData);\n\n      // Resolve the promise immediately\n      resolve();\n    });\n  }\n  onMessage(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n  disconnect() {\n    if (this.socket) {\n      console.log('Manually disconnecting socket');\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n  getChatHistory() {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.socket.connected) {\n        console.error('Socket not connected');\n        resolve([]); // Return empty array instead of rejecting for better UX\n        return;\n      }\n      console.log('Requesting chat history for:', this.userId, this.sessionId);\n\n      // Set a timeout in case the server doesn't respond\n      const historyTimeout = setTimeout(() => {\n        console.error('Chat history timeout');\n        resolve([]); // Return empty array on timeout\n      }, 8000);\n      this.socket.emit('chat:history', {\n        userId: this.userId,\n        sessionId: this.sessionId\n      });\n      this.socket.once('chat:history', history => {\n        console.log('Received chat history:', history);\n        clearTimeout(historyTimeout);\n\n        // Check if history is valid\n        if (!Array.isArray(history)) {\n          console.error('Invalid chat history format:', history);\n          resolve([]);\n          return;\n        }\n\n        // Convert timestamps to Date objects and enhance messages\n        const processedHistory = history.map(msg => {\n          var _msg$metadata, _msg$metadata2, _msg$metadata3;\n          // Enhanced message with UI-specific properties\n          const enhancedMsg = {\n            ...msg,\n            timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp,\n            showCalendar: msg.showCalendar || ((_msg$metadata = msg.metadata) === null || _msg$metadata === void 0 ? void 0 : _msg$metadata.showCalendar) || false,\n            selectedDate: msg.selectedDate || ((_msg$metadata2 = msg.metadata) === null || _msg$metadata2 === void 0 ? void 0 : _msg$metadata2.selectedDate),\n            availableTimes: msg.availableTimes || ((_msg$metadata3 = msg.metadata) === null || _msg$metadata3 === void 0 ? void 0 : _msg$metadata3.availableTimes)\n          };\n          return enhancedMsg;\n        });\n        resolve(processedHistory);\n      });\n      this.socket.once('chat:error', error => {\n        console.error('Chat history error:', error);\n        clearTimeout(historyTimeout);\n        resolve([]); // Return empty array instead of rejecting\n      });\n    });\n  }\n\n  // Check if socket is connected\n  isConnected() {\n    var _this$socket2;\n    return ((_this$socket2 = this.socket) === null || _this$socket2 === void 0 ? void 0 : _this$socket2.connected) || false;\n  }\n\n  // Get socket ID for debugging\n  getSocketId() {\n    var _this$socket3;\n    return ((_this$socket3 = this.socket) === null || _this$socket3 === void 0 ? void 0 : _this$socket3.id) || null;\n  }\n\n  // Find the last user message with a date, for use when handling time selection\n  findLastUserMessageWithDate() {\n    // We need to keep track of recent messages for this to work\n    let recentMessages = [];\n\n    // Extract recent messages from listeners\n    this.messageListeners.forEach(listener => {\n      // Get the captured messages from the listener function's closure\n      try {\n        // This is a bit of a hack - we're assuming the messages state from ChatWidget\n        // is accessible via a closure in the listener function\n        const messages = listener.__capturedMessages;\n        if (Array.isArray(messages)) {\n          recentMessages = messages;\n        }\n      } catch (e) {\n        // Ignore any errors in this attempt\n      }\n    });\n\n    // If we couldn't get the messages, we'll just use some defaults\n    if (recentMessages.length === 0) {\n      const date = new Date();\n      const formattedDate = date.toISOString().split('T')[0];\n\n      // Return a fake message with today's date\n      return {\n        id: 0,\n        text: 'Generated date message',\n        sender: 'user',\n        timestamp: new Date(),\n        selectedDate: formattedDate\n      };\n    }\n\n    // Look through the messages in reverse order to find the most recent one with a date\n    for (let i = recentMessages.length - 1; i >= 0; i--) {\n      const msg = recentMessages[i];\n      if (msg.sender === 'user' && msg.selectedDate) {\n        return msg;\n      }\n    }\n    return null;\n  }\n}\n\n// Export the singleton instance\n_SocketService = SocketService;\nSocketService.instance = void 0;\nexport default SocketService.getInstance();","map":{"version":3,"names":["io","BACKEND_URL","process","env","REACT_APP_BACKEND_URL","SocketService","constructor","socket","userId","sessionId","userType","messageListeners","processedMessages","Set","connecting","console","log","localStorage","getItem","Date","now","setItem","getInstance","instance","connect","Promise","resolve","reject","connected","setTimeout","Error","disconnect","transports","reconnectionAttempts","timeout","connectionTimeout","error","on","_this$socket","id","clearTimeout","message","_message$metadata","_message$metadata2","_message$metadata3","messageKey","requestId","toString","Math","random","substring","has","add","size","iterator","values","i","value","next","delete","timestamp","enhancedMessage","showCalendar","metadata","selectedDate","availableTimes","sender","lowerText","text","toLowerCase","includes","lastUserMsg","findLastUserMessageWithDate","length","start","end","forEach","listener","sendMessage","messageData","emit","onMessage","callback","push","filter","cb","getChatHistory","historyTimeout","once","history","Array","isArray","processedHistory","map","msg","_msg$metadata","_msg$metadata2","_msg$metadata3","enhancedMsg","isConnected","_this$socket2","getSocketId","_this$socket3","recentMessages","messages","__capturedMessages","e","date","formattedDate","toISOString","split","_SocketService"],"sources":["C:/Users/haris/clark-guide/clark-chatbox/frontend/src/services/socketService.ts"],"sourcesContent":["import { io, Socket } from 'socket.io-client';\r\nimport { UserType } from '../contexts/UserContext';\r\n\r\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\r\n\r\nexport interface ChatMessage {\r\n  id?: string | number;\r\n  text: string;\r\n  sender: 'user' | 'ai';\r\n  timestamp: Date;\r\n  metadata?: any;\r\n  showCalendar?: boolean; // Add this explicit property\r\n  selectedDate?: string;   // Add this explicit property\r\n  availableTimes?: { start: string; end: string }[]; // Add this explicit property\r\n}\r\n\r\n// Singleton instance to ensure only one socket connection\r\nclass SocketService {\r\n  private static instance: SocketService; // Singleton instance\r\n  private socket: Socket | null = null;\r\n  private userId: string | null = null;\r\n  private sessionId: string | null = null;\r\n  private userType: UserType = 'student';\r\n  private messageListeners: Array<(message: ChatMessage) => void> = [];\r\n  private processedMessages = new Set<string>(); // Track message IDs we've already processed\r\n  private connecting = false; // Flag to prevent multiple simultaneous connection attempts\r\n  \r\n  // Private constructor for singleton\r\n  private constructor() {\r\n    console.log('SocketService instance created');\r\n    // Initialize userId and sessionId from localStorage if available\r\n    this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\r\n    this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\r\n    \r\n    // Store IDs for persistence\r\n    localStorage.setItem('userId', this.userId);\r\n    localStorage.setItem('sessionId', this.sessionId);\r\n  }\r\n  \r\n  // Get singleton instance\r\n  public static getInstance(): SocketService {\r\n    if (!SocketService.instance) {\r\n      SocketService.instance = new SocketService();\r\n    }\r\n    return SocketService.instance;\r\n  }\r\n  \r\n  connect(userType: UserType): Promise<boolean> {\r\n    return new Promise((resolve, reject) => {\r\n      // If already connected, just resolve\r\n      if (this.socket && this.socket.connected) {\r\n        console.log('Socket already connected, reusing connection');\r\n        this.userType = userType; // Update userType\r\n        resolve(true);\r\n        return;\r\n      }\r\n      \r\n      // If currently trying to connect, wait\r\n      if (this.connecting) {\r\n        console.log('Connection attempt already in progress');\r\n        setTimeout(() => {\r\n          if (this.socket && this.socket.connected) {\r\n            resolve(true);\r\n          } else {\r\n            reject(new Error('Connection in progress timed out'));\r\n          }\r\n        }, 5000);\r\n        return;\r\n      }\r\n      \r\n      this.connecting = true;\r\n      console.log('Starting new socket connection');\r\n      \r\n      // Disconnect existing socket if any\r\n      if (this.socket) {\r\n        console.log('Disconnecting existing socket');\r\n        this.socket.disconnect();\r\n        this.socket = null;\r\n      }\r\n      \r\n      console.log('Connecting to socket server at:', BACKEND_URL);\r\n      this.socket = io(BACKEND_URL, {\r\n        transports: ['websocket', 'polling'],\r\n        reconnectionAttempts: 5,\r\n        timeout: 10000\r\n      });\r\n      \r\n      this.userType = userType;\r\n      \r\n      // Set up connection timeout\r\n      const connectionTimeout = setTimeout(() => {\r\n        console.error('Connection timeout');\r\n        this.connecting = false;\r\n        reject(new Error('Connection timeout'));\r\n      }, 10000);\r\n      \r\n      this.socket.on('connect', () => {\r\n        console.log('Successfully connected to server with socket ID:', this.socket?.id);\r\n        clearTimeout(connectionTimeout);\r\n        this.connecting = false;\r\n        resolve(true);\r\n      });\r\n      \r\n      this.socket.on('message:receive', (message: ChatMessage & { requestId?: string }) => {\r\n        console.log('Received message:', message);\r\n        \r\n        // Generate a message key for deduplication\r\n        const messageKey = message.requestId || \r\n                          (message.id ? message.id.toString() : \r\n                          `msg-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`);\r\n        \r\n        // Check if we've already processed this message\r\n        if (this.processedMessages.has(messageKey)) {\r\n          console.log(`Skipping duplicate message with ID: ${messageKey}`);\r\n          return;\r\n        }\r\n        \r\n        // Mark this message as processed\r\n        this.processedMessages.add(messageKey);\r\n        \r\n        // Limit the size of the processed messages set to avoid memory leaks\r\n        if (this.processedMessages.size > 100) {\r\n          // Remove the oldest items (first 50) when we hit the limit\r\n          const iterator = this.processedMessages.values();\r\n          for (let i = 0; i < 50; i++) {\r\n            const value = iterator.next().value;\r\n            if (value) this.processedMessages.delete(value);\r\n          }\r\n        }\r\n        \r\n        // Convert timestamp to Date object if it's a string\r\n        if (typeof message.timestamp === 'string') {\r\n          message.timestamp = new Date(message.timestamp);\r\n        }\r\n        \r\n        // Transfer special properties from the received message or its metadata\r\n        const enhancedMessage: ChatMessage = {\r\n          ...message,\r\n          // Ensure these properties are directly exposed at the message level\r\n          showCalendar: message.showCalendar || message.metadata?.showCalendar || false,\r\n          selectedDate: message.selectedDate || message.metadata?.selectedDate,\r\n          availableTimes: message.availableTimes || message.metadata?.availableTimes\r\n        };\r\n        \r\n        // Check for specific keywords in text that would indicate calendar needs\r\n        if (enhancedMessage.sender === 'ai' && !enhancedMessage.showCalendar) {\r\n          const lowerText = enhancedMessage.text.toLowerCase();\r\n          \r\n        // Check if message suggests selecting a different date\r\n        if (\r\n          (lowerText.includes('no rooms available') && lowerText.includes('different date')) ||\r\n          (lowerText.includes('try a different date')) ||\r\n          (lowerText.includes('select a date')) ||\r\n          (lowerText.includes('what date would you like'))\r\n        ) {\r\n          console.log('Auto-enabling calendar based on message content');\r\n          enhancedMessage.showCalendar = true;\r\n        }\r\n        \r\n        // Check if message is asking for time selection\r\n        if (lowerText.includes('what time would you like') || \r\n            lowerText.includes('select a time') || \r\n            lowerText.includes('select from the available') ||\r\n            lowerText.includes('time slots') ||\r\n            lowerText.includes('available slots')) {\r\n          console.log('Detected time selection request');\r\n          \r\n          // Find the last user message that might have a date\r\n          const lastUserMsg = this.findLastUserMessageWithDate();\r\n          if (lastUserMsg) {\r\n            console.log('Found date from previous message:', lastUserMsg.selectedDate);\r\n            enhancedMessage.selectedDate = lastUserMsg.selectedDate;\r\n            \r\n            // If we don't have availableTimes in the metadata, create some default ones\r\n            if (!enhancedMessage.availableTimes || enhancedMessage.availableTimes.length === 0) {\r\n              console.log('No time slots in metadata, creating default ones');\r\n              enhancedMessage.availableTimes = [\r\n                { start: '09:00', end: '10:00' },\r\n                { start: '11:00', end: '12:00' },\r\n                { start: '13:30', end: '14:30' },\r\n                { start: '15:00', end: '16:00' },\r\n                { start: '17:30', end: '18:30' }\r\n              ];\r\n            }\r\n          }\r\n        }\r\n        }\r\n        \r\n        // Notify all listeners with the enhanced message\r\n        this.messageListeners.forEach(listener => listener(enhancedMessage));\r\n      });\r\n      \r\n      this.socket.on('disconnect', () => {\r\n        console.log('Disconnected from server');\r\n        this.connecting = false;\r\n      });\r\n      \r\n      this.socket.on('connect_error', (error) => {\r\n        console.error('Connection error:', error);\r\n        clearTimeout(connectionTimeout);\r\n        this.connecting = false;\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n  \r\n  sendMessage(text: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || !this.socket.connected) {\r\n        console.error('Socket not connected');\r\n        reject(new Error('Socket not connected. Please refresh and try again.'));\r\n        return;\r\n      }\r\n      \r\n      const messageData = {\r\n        text,\r\n        userId: this.userId,\r\n        userType: this.userType,\r\n        sessionId: this.sessionId\r\n      };\r\n      \r\n      console.log('Sending message:', messageData);\r\n      \r\n      // Just emit the message and resolve immediately - no need to wait for acknowledgment\r\n      // The actual response will come through the message:receive event handler\r\n      this.socket.emit('message:send', messageData);\r\n      \r\n      // Resolve the promise immediately\r\n      resolve();\r\n    });\r\n  }\r\n  \r\n  onMessage(callback: (message: ChatMessage) => void) {\r\n    this.messageListeners.push(callback);\r\n    return () => {\r\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\r\n    };\r\n  }\r\n  \r\n  disconnect() {\r\n    if (this.socket) {\r\n      console.log('Manually disconnecting socket');\r\n      this.socket.disconnect();\r\n      this.socket = null;\r\n    }\r\n  }\r\n  \r\n  getChatHistory(): Promise<ChatMessage[]> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || !this.socket.connected) {\r\n        console.error('Socket not connected');\r\n        resolve([]); // Return empty array instead of rejecting for better UX\r\n        return;\r\n      }\r\n      \r\n      console.log('Requesting chat history for:', this.userId, this.sessionId);\r\n      \r\n      // Set a timeout in case the server doesn't respond\r\n      const historyTimeout = setTimeout(() => {\r\n        console.error('Chat history timeout');\r\n        resolve([]); // Return empty array on timeout\r\n      }, 8000);\r\n      \r\n      this.socket.emit('chat:history', {\r\n        userId: this.userId,\r\n        sessionId: this.sessionId\r\n      });\r\n      \r\n      this.socket.once('chat:history', (history: ChatMessage[]) => {\r\n        console.log('Received chat history:', history);\r\n        clearTimeout(historyTimeout);\r\n        \r\n        // Check if history is valid\r\n        if (!Array.isArray(history)) {\r\n          console.error('Invalid chat history format:', history);\r\n          resolve([]);\r\n          return;\r\n        }\r\n        \r\n        // Convert timestamps to Date objects and enhance messages\r\n        const processedHistory = history.map(msg => {\r\n          // Enhanced message with UI-specific properties\r\n          const enhancedMsg: ChatMessage = {\r\n            ...msg,\r\n            timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp,\r\n            showCalendar: msg.showCalendar || msg.metadata?.showCalendar || false,\r\n            selectedDate: msg.selectedDate || msg.metadata?.selectedDate,\r\n            availableTimes: msg.availableTimes || msg.metadata?.availableTimes\r\n          };\r\n          return enhancedMsg;\r\n        });\r\n        resolve(processedHistory);\r\n      });\r\n      \r\n      this.socket.once('chat:error', (error) => {\r\n        console.error('Chat history error:', error);\r\n        clearTimeout(historyTimeout);\r\n        resolve([]); // Return empty array instead of rejecting\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Check if socket is connected\r\n  isConnected(): boolean {\r\n    return this.socket?.connected || false;\r\n  }\r\n  \r\n  // Get socket ID for debugging\r\n  getSocketId(): string | null {\r\n    return this.socket?.id || null;\r\n  }\r\n  \r\n  // Find the last user message with a date, for use when handling time selection\r\n  private findLastUserMessageWithDate(): ChatMessage | null {\r\n    // We need to keep track of recent messages for this to work\r\n    let recentMessages: ChatMessage[] = [];\r\n    \r\n    // Extract recent messages from listeners\r\n    this.messageListeners.forEach(listener => {\r\n      // Get the captured messages from the listener function's closure\r\n      try {\r\n        // This is a bit of a hack - we're assuming the messages state from ChatWidget\r\n        // is accessible via a closure in the listener function\r\n        const messages = (listener as any).__capturedMessages;\r\n        if (Array.isArray(messages)) {\r\n          recentMessages = messages;\r\n        }\r\n      } catch (e) {\r\n        // Ignore any errors in this attempt\r\n      }\r\n    });\r\n    \r\n    // If we couldn't get the messages, we'll just use some defaults\r\n    if (recentMessages.length === 0) {\r\n      const date = new Date();\r\n      const formattedDate = date.toISOString().split('T')[0];\r\n      \r\n      // Return a fake message with today's date\r\n      return {\r\n        id: 0,\r\n        text: 'Generated date message',\r\n        sender: 'user',\r\n        timestamp: new Date(),\r\n        selectedDate: formattedDate\r\n      };\r\n    }\r\n    \r\n    // Look through the messages in reverse order to find the most recent one with a date\r\n    for (let i = recentMessages.length - 1; i >= 0; i--) {\r\n      const msg = recentMessages[i];\r\n      if (msg.sender === 'user' && msg.selectedDate) {\r\n        return msg;\r\n      }\r\n    }\r\n    \r\n    return null;\r\n  }\r\n}\r\n\r\n// Export the singleton instance\r\nexport default SocketService.getInstance();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}