{"ast":null,"code":"import { io } from 'socket.io-client';\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\nclass SocketService {\n  constructor() {\n    this.socket = null;\n    this.userId = null;\n    this.sessionId = null;\n    this.userType = 'student';\n    this.messageListeners = [];\n    this.processedMessages = new Set();\n  }\n  // Track message IDs we've already processed\n\n  connect(userType) {\n    return new Promise((resolve, reject) => {\n      if (this.socket && this.socket.connected) {\n        console.log('Socket already connected');\n        resolve(true);\n        return;\n      }\n\n      // Disconnect existing socket if any\n      if (this.socket) {\n        this.socket.disconnect();\n      }\n      console.log('Connecting to socket server at:', BACKEND_URL);\n      this.socket = io(BACKEND_URL, {\n        transports: ['websocket', 'polling'],\n        reconnectionAttempts: 5,\n        timeout: 10000\n      });\n      this.userType = userType;\n      this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\n      this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\n\n      // Store IDs for persistence\n      localStorage.setItem('userId', this.userId);\n      localStorage.setItem('sessionId', this.sessionId);\n\n      // Set up connection timeout\n      const connectionTimeout = setTimeout(() => {\n        console.error('Connection timeout');\n        reject(new Error('Connection timeout'));\n      }, 10000);\n      this.socket.on('connect', () => {\n        console.log('Successfully connected to server');\n        clearTimeout(connectionTimeout);\n        resolve(true);\n      });\n      this.socket.on('message:receive', message => {\n        var _message$id;\n        console.log('Received message:', message);\n\n        // Check if we've already processed this message (based on requestId or message ID)\n        const messageKey = message.requestId || ((_message$id = message.id) === null || _message$id === void 0 ? void 0 : _message$id.toString());\n        if (messageKey && this.processedMessages.has(messageKey)) {\n          console.log(`Skipping duplicate message with ID: ${messageKey}`);\n          return;\n        }\n\n        // Mark this message as processed\n        if (messageKey) {\n          this.processedMessages.add(messageKey);\n\n          // Limit the size of the processed messages set to avoid memory leaks\n          if (this.processedMessages.size > 100) {\n            // Remove the oldest items (first 50) when we hit the limit\n            const iterator = this.processedMessages.values();\n            for (let i = 0; i < 50; i++) {\n              this.processedMessages.delete(iterator.next().value);\n            }\n          }\n        }\n\n        // Convert timestamp to Date object if it's a string\n        if (typeof message.timestamp === 'string') {\n          message.timestamp = new Date(message.timestamp);\n        }\n\n        // Notify all listeners\n        this.messageListeners.forEach(listener => listener(message));\n      });\n      this.socket.on('disconnect', () => {\n        console.log('Disconnected from server');\n      });\n      this.socket.on('connect_error', error => {\n        console.error('Connection error:', error);\n        clearTimeout(connectionTimeout);\n        reject(error);\n      });\n    });\n  }\n  sendMessage(text) {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.socket.connected) {\n        console.error('Socket not connected');\n        reject(new Error('Socket not connected. Please refresh and try again.'));\n        return;\n      }\n      const messageData = {\n        text,\n        userId: this.userId,\n        userType: this.userType,\n        sessionId: this.sessionId\n      };\n      console.log('Sending message:', messageData);\n\n      // Set up a timeout in case the server doesn't respond\n      const messageTimeout = setTimeout(() => {\n        console.error('Message sending timeout');\n        reject(new Error('Server did not respond. Please try again later.'));\n      }, 15000);\n\n      // Send the message\n      this.socket.emit('message:send', messageData, () => {\n        clearTimeout(messageTimeout);\n        resolve();\n      });\n    });\n  }\n  onMessage(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n  getChatHistory() {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.socket.connected) {\n        console.error('Socket not connected');\n        resolve([]); // Return empty array instead of rejecting for better UX\n        return;\n      }\n      console.log('Requesting chat history for:', this.userId, this.sessionId);\n\n      // Set a timeout in case the server doesn't respond\n      const historyTimeout = setTimeout(() => {\n        console.error('Chat history timeout');\n        resolve([]); // Return empty array on timeout\n      }, 8000);\n      this.socket.emit('chat:history', {\n        userId: this.userId,\n        sessionId: this.sessionId\n      });\n      this.socket.once('chat:history', history => {\n        console.log('Received chat history:', history);\n        clearTimeout(historyTimeout);\n\n        // Check if history is valid\n        if (!Array.isArray(history)) {\n          console.error('Invalid chat history format:', history);\n          resolve([]);\n          return;\n        }\n\n        // Convert timestamps to Date objects\n        const processedHistory = history.map(msg => ({\n          ...msg,\n          timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp\n        }));\n        resolve(processedHistory);\n      });\n      this.socket.once('chat:error', error => {\n        console.error('Chat history error:', error);\n        clearTimeout(historyTimeout);\n        resolve([]); // Return empty array instead of rejecting\n      });\n    });\n  }\n\n  // Check if socket is connected\n  isConnected() {\n    var _this$socket;\n    return ((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.connected) || false;\n  }\n}\nexport default new SocketService();","map":{"version":3,"names":["io","BACKEND_URL","process","env","REACT_APP_BACKEND_URL","SocketService","constructor","socket","userId","sessionId","userType","messageListeners","processedMessages","Set","connect","Promise","resolve","reject","connected","console","log","disconnect","transports","reconnectionAttempts","timeout","localStorage","getItem","Date","now","setItem","connectionTimeout","setTimeout","error","Error","on","clearTimeout","message","_message$id","messageKey","requestId","id","toString","has","add","size","iterator","values","i","delete","next","value","timestamp","forEach","listener","sendMessage","text","messageData","messageTimeout","emit","onMessage","callback","push","filter","cb","getChatHistory","historyTimeout","once","history","Array","isArray","processedHistory","map","msg","isConnected","_this$socket"],"sources":["C:/Users/haris/clark-guide/clark-chatbox/frontend/src/services/socketService.ts"],"sourcesContent":["import { io, Socket } from 'socket.io-client';\r\nimport { UserType } from '../contexts/UserContext';\r\n\r\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\r\n\r\nexport interface ChatMessage {\r\n  id?: string | number;\r\n  text: string;\r\n  sender: 'user' | 'ai';\r\n  timestamp: Date;\r\n  metadata?: any;\r\n}\r\n\r\nclass SocketService {\r\n  private socket: Socket | null = null;\r\n  private userId: string | null = null;\r\n  private sessionId: string | null = null;\r\n  private userType: UserType = 'student';\r\n  private messageListeners: Array<(message: ChatMessage) => void> = [];\r\n  private processedMessages = new Set<string>(); // Track message IDs we've already processed\r\n  \r\n  connect(userType: UserType): Promise<boolean> {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.socket && this.socket.connected) {\r\n        console.log('Socket already connected');\r\n        resolve(true);\r\n        return;\r\n      }\r\n      \r\n      // Disconnect existing socket if any\r\n      if (this.socket) {\r\n        this.socket.disconnect();\r\n      }\r\n      \r\n      console.log('Connecting to socket server at:', BACKEND_URL);\r\n      this.socket = io(BACKEND_URL, {\r\n        transports: ['websocket', 'polling'],\r\n        reconnectionAttempts: 5,\r\n        timeout: 10000\r\n      });\r\n      \r\n      this.userType = userType;\r\n      this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\r\n      this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\r\n      \r\n      // Store IDs for persistence\r\n      localStorage.setItem('userId', this.userId);\r\n      localStorage.setItem('sessionId', this.sessionId);\r\n      \r\n      // Set up connection timeout\r\n      const connectionTimeout = setTimeout(() => {\r\n        console.error('Connection timeout');\r\n        reject(new Error('Connection timeout'));\r\n      }, 10000);\r\n      \r\n      this.socket.on('connect', () => {\r\n        console.log('Successfully connected to server');\r\n        clearTimeout(connectionTimeout);\r\n        resolve(true);\r\n      });\r\n      \r\n      this.socket.on('message:receive', (message: ChatMessage & { requestId?: string }) => {\r\n        console.log('Received message:', message);\r\n        \r\n        // Check if we've already processed this message (based on requestId or message ID)\r\n        const messageKey = message.requestId || message.id?.toString();\r\n        if (messageKey && this.processedMessages.has(messageKey)) {\r\n          console.log(`Skipping duplicate message with ID: ${messageKey}`);\r\n          return;\r\n        }\r\n        \r\n        // Mark this message as processed\r\n        if (messageKey) {\r\n          this.processedMessages.add(messageKey);\r\n          \r\n          // Limit the size of the processed messages set to avoid memory leaks\r\n          if (this.processedMessages.size > 100) {\r\n            // Remove the oldest items (first 50) when we hit the limit\r\n            const iterator = this.processedMessages.values();\r\n            for (let i = 0; i < 50; i++) {\r\n              this.processedMessages.delete(iterator.next().value);\r\n            }\r\n          }\r\n        }\r\n        \r\n        // Convert timestamp to Date object if it's a string\r\n        if (typeof message.timestamp === 'string') {\r\n          message.timestamp = new Date(message.timestamp);\r\n        }\r\n        \r\n        // Notify all listeners\r\n        this.messageListeners.forEach(listener => listener(message));\r\n      });\r\n      \r\n      this.socket.on('disconnect', () => {\r\n        console.log('Disconnected from server');\r\n      });\r\n      \r\n      this.socket.on('connect_error', (error) => {\r\n        console.error('Connection error:', error);\r\n        clearTimeout(connectionTimeout);\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n  \r\n  sendMessage(text: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || !this.socket.connected) {\r\n        console.error('Socket not connected');\r\n        reject(new Error('Socket not connected. Please refresh and try again.'));\r\n        return;\r\n      }\r\n      \r\n      const messageData = {\r\n        text,\r\n        userId: this.userId,\r\n        userType: this.userType,\r\n        sessionId: this.sessionId\r\n      };\r\n      \r\n      console.log('Sending message:', messageData);\r\n      \r\n      // Set up a timeout in case the server doesn't respond\r\n      const messageTimeout = setTimeout(() => {\r\n        console.error('Message sending timeout');\r\n        reject(new Error('Server did not respond. Please try again later.'));\r\n      }, 15000);\r\n      \r\n      // Send the message\r\n      this.socket.emit('message:send', messageData, () => {\r\n        clearTimeout(messageTimeout);\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n  \r\n  onMessage(callback: (message: ChatMessage) => void) {\r\n    this.messageListeners.push(callback);\r\n    return () => {\r\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\r\n    };\r\n  }\r\n  \r\n  disconnect() {\r\n    if (this.socket) {\r\n      this.socket.disconnect();\r\n      this.socket = null;\r\n    }\r\n  }\r\n  \r\n  getChatHistory(): Promise<ChatMessage[]> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || !this.socket.connected) {\r\n        console.error('Socket not connected');\r\n        resolve([]); // Return empty array instead of rejecting for better UX\r\n        return;\r\n      }\r\n      \r\n      console.log('Requesting chat history for:', this.userId, this.sessionId);\r\n      \r\n      // Set a timeout in case the server doesn't respond\r\n      const historyTimeout = setTimeout(() => {\r\n        console.error('Chat history timeout');\r\n        resolve([]); // Return empty array on timeout\r\n      }, 8000);\r\n      \r\n      this.socket.emit('chat:history', {\r\n        userId: this.userId,\r\n        sessionId: this.sessionId\r\n      });\r\n      \r\n      this.socket.once('chat:history', (history: ChatMessage[]) => {\r\n        console.log('Received chat history:', history);\r\n        clearTimeout(historyTimeout);\r\n        \r\n        // Check if history is valid\r\n        if (!Array.isArray(history)) {\r\n          console.error('Invalid chat history format:', history);\r\n          resolve([]);\r\n          return;\r\n        }\r\n        \r\n        // Convert timestamps to Date objects\r\n        const processedHistory = history.map(msg => ({\r\n          ...msg,\r\n          timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp\r\n        }));\r\n        resolve(processedHistory);\r\n      });\r\n      \r\n      this.socket.once('chat:error', (error) => {\r\n        console.error('Chat history error:', error);\r\n        clearTimeout(historyTimeout);\r\n        resolve([]); // Return empty array instead of rejecting\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Check if socket is connected\r\n  isConnected(): boolean {\r\n    return this.socket?.connected || false;\r\n  }\r\n}\r\n\r\nexport default new SocketService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}