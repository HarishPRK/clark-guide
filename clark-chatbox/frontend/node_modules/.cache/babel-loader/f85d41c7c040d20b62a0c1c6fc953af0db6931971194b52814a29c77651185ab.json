{"ast":null,"code":"import { io } from 'socket.io-client';\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\nclass SocketService {\n  constructor() {\n    this.socket = null;\n    this.userId = null;\n    this.sessionId = null;\n    this.userType = 'student';\n    this.messageListeners = [];\n  }\n  connect(userType) {\n    return new Promise((resolve, reject) => {\n      if (this.socket && this.socket.connected) {\n        console.log('Socket already connected');\n        resolve(true);\n        return;\n      }\n\n      // Disconnect existing socket if any\n      if (this.socket) {\n        this.socket.disconnect();\n      }\n      console.log('Connecting to socket server at:', BACKEND_URL);\n      this.socket = io(BACKEND_URL, {\n        transports: ['websocket', 'polling'],\n        reconnectionAttempts: 5,\n        timeout: 10000\n      });\n      this.userType = userType;\n      this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\n      this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\n\n      // Store IDs for persistence\n      localStorage.setItem('userId', this.userId);\n      localStorage.setItem('sessionId', this.sessionId);\n\n      // Set up connection timeout\n      const connectionTimeout = setTimeout(() => {\n        console.error('Connection timeout');\n        reject(new Error('Connection timeout'));\n      }, 10000);\n      this.socket.on('connect', () => {\n        console.log('Successfully connected to server');\n        clearTimeout(connectionTimeout);\n        resolve(true);\n      });\n      this.socket.on('message:receive', message => {\n        console.log('Received message:', message);\n        // Convert timestamp to Date object if it's a string\n        if (typeof message.timestamp === 'string') {\n          message.timestamp = new Date(message.timestamp);\n        }\n        this.messageListeners.forEach(listener => listener(message));\n      });\n      this.socket.on('disconnect', () => {\n        console.log('Disconnected from server');\n      });\n      this.socket.on('connect_error', error => {\n        console.error('Connection error:', error);\n        clearTimeout(connectionTimeout);\n        reject(error);\n      });\n    });\n  }\n  sendMessage(text) {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.socket.connected) {\n        console.error('Socket not connected');\n        reject(new Error('Socket not connected. Please refresh and try again.'));\n        return;\n      }\n      const messageData = {\n        text,\n        userId: this.userId,\n        userType: this.userType,\n        sessionId: this.sessionId\n      };\n      console.log('Sending message:', messageData);\n\n      // Set up a timeout in case the server doesn't respond\n      const messageTimeout = setTimeout(() => {\n        console.error('Message sending timeout');\n        reject(new Error('Server did not respond. Please try again later.'));\n      }, 15000);\n\n      // Send the message\n      this.socket.emit('message:send', messageData, () => {\n        clearTimeout(messageTimeout);\n        resolve();\n      });\n    });\n  }\n  onMessage(callback) {\n    this.messageListeners.push(callback);\n    return () => {\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\n    };\n  }\n  disconnect() {\n    if (this.socket) {\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n  getChatHistory() {\n    return new Promise((resolve, reject) => {\n      if (!this.socket || !this.socket.connected) {\n        console.error('Socket not connected');\n        resolve([]); // Return empty array instead of rejecting for better UX\n        return;\n      }\n      console.log('Requesting chat history for:', this.userId, this.sessionId);\n\n      // Set a timeout in case the server doesn't respond\n      const historyTimeout = setTimeout(() => {\n        console.error('Chat history timeout');\n        resolve([]); // Return empty array on timeout\n      }, 8000);\n      this.socket.emit('chat:history', {\n        userId: this.userId,\n        sessionId: this.sessionId\n      });\n      this.socket.once('chat:history', history => {\n        console.log('Received chat history:', history);\n        clearTimeout(historyTimeout);\n\n        // Check if history is valid\n        if (!Array.isArray(history)) {\n          console.error('Invalid chat history format:', history);\n          resolve([]);\n          return;\n        }\n\n        // Convert timestamps to Date objects\n        const processedHistory = history.map(msg => ({\n          ...msg,\n          timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp\n        }));\n        resolve(processedHistory);\n      });\n      this.socket.once('chat:error', error => {\n        console.error('Chat history error:', error);\n        clearTimeout(historyTimeout);\n        resolve([]); // Return empty array instead of rejecting\n      });\n    });\n  }\n\n  // Check if socket is connected\n  isConnected() {\n    var _this$socket;\n    return ((_this$socket = this.socket) === null || _this$socket === void 0 ? void 0 : _this$socket.connected) || false;\n  }\n}\nexport default new SocketService();","map":{"version":3,"names":["io","BACKEND_URL","process","env","REACT_APP_BACKEND_URL","SocketService","constructor","socket","userId","sessionId","userType","messageListeners","connect","Promise","resolve","reject","connected","console","log","disconnect","transports","reconnectionAttempts","timeout","localStorage","getItem","Date","now","setItem","connectionTimeout","setTimeout","error","Error","on","clearTimeout","message","timestamp","forEach","listener","sendMessage","text","messageData","messageTimeout","emit","onMessage","callback","push","filter","cb","getChatHistory","historyTimeout","once","history","Array","isArray","processedHistory","map","msg","isConnected","_this$socket"],"sources":["C:/Users/haris/clark-guide/clark-chatbox/frontend/src/services/socketService.ts"],"sourcesContent":["import { io, Socket } from 'socket.io-client';\r\nimport { UserType } from '../contexts/UserContext';\r\n\r\nconst BACKEND_URL = process.env.REACT_APP_BACKEND_URL || 'http://localhost:5000';\r\n\r\nexport interface ChatMessage {\r\n  id?: string | number;\r\n  text: string;\r\n  sender: 'user' | 'ai';\r\n  timestamp: Date;\r\n  metadata?: any;\r\n}\r\n\r\nclass SocketService {\r\n  private socket: Socket | null = null;\r\n  private userId: string | null = null;\r\n  private sessionId: string | null = null;\r\n  private userType: UserType = 'student';\r\n  private messageListeners: Array<(message: ChatMessage) => void> = [];\r\n  \r\n  connect(userType: UserType): Promise<boolean> {\r\n    return new Promise((resolve, reject) => {\r\n      if (this.socket && this.socket.connected) {\r\n        console.log('Socket already connected');\r\n        resolve(true);\r\n        return;\r\n      }\r\n      \r\n      // Disconnect existing socket if any\r\n      if (this.socket) {\r\n        this.socket.disconnect();\r\n      }\r\n      \r\n      console.log('Connecting to socket server at:', BACKEND_URL);\r\n      this.socket = io(BACKEND_URL, {\r\n        transports: ['websocket', 'polling'],\r\n        reconnectionAttempts: 5,\r\n        timeout: 10000\r\n      });\r\n      \r\n      this.userType = userType;\r\n      this.userId = localStorage.getItem('userId') || `user-${Date.now()}`;\r\n      this.sessionId = localStorage.getItem('sessionId') || `session-${Date.now()}`;\r\n      \r\n      // Store IDs for persistence\r\n      localStorage.setItem('userId', this.userId);\r\n      localStorage.setItem('sessionId', this.sessionId);\r\n      \r\n      // Set up connection timeout\r\n      const connectionTimeout = setTimeout(() => {\r\n        console.error('Connection timeout');\r\n        reject(new Error('Connection timeout'));\r\n      }, 10000);\r\n      \r\n      this.socket.on('connect', () => {\r\n        console.log('Successfully connected to server');\r\n        clearTimeout(connectionTimeout);\r\n        resolve(true);\r\n      });\r\n      \r\n      this.socket.on('message:receive', (message: ChatMessage) => {\r\n        console.log('Received message:', message);\r\n        // Convert timestamp to Date object if it's a string\r\n        if (typeof message.timestamp === 'string') {\r\n          message.timestamp = new Date(message.timestamp);\r\n        }\r\n        \r\n        this.messageListeners.forEach(listener => listener(message));\r\n      });\r\n      \r\n      this.socket.on('disconnect', () => {\r\n        console.log('Disconnected from server');\r\n      });\r\n      \r\n      this.socket.on('connect_error', (error) => {\r\n        console.error('Connection error:', error);\r\n        clearTimeout(connectionTimeout);\r\n        reject(error);\r\n      });\r\n    });\r\n  }\r\n  \r\n  sendMessage(text: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || !this.socket.connected) {\r\n        console.error('Socket not connected');\r\n        reject(new Error('Socket not connected. Please refresh and try again.'));\r\n        return;\r\n      }\r\n      \r\n      const messageData = {\r\n        text,\r\n        userId: this.userId,\r\n        userType: this.userType,\r\n        sessionId: this.sessionId\r\n      };\r\n      \r\n      console.log('Sending message:', messageData);\r\n      \r\n      // Set up a timeout in case the server doesn't respond\r\n      const messageTimeout = setTimeout(() => {\r\n        console.error('Message sending timeout');\r\n        reject(new Error('Server did not respond. Please try again later.'));\r\n      }, 15000);\r\n      \r\n      // Send the message\r\n      this.socket.emit('message:send', messageData, () => {\r\n        clearTimeout(messageTimeout);\r\n        resolve();\r\n      });\r\n    });\r\n  }\r\n  \r\n  onMessage(callback: (message: ChatMessage) => void) {\r\n    this.messageListeners.push(callback);\r\n    return () => {\r\n      this.messageListeners = this.messageListeners.filter(cb => cb !== callback);\r\n    };\r\n  }\r\n  \r\n  disconnect() {\r\n    if (this.socket) {\r\n      this.socket.disconnect();\r\n      this.socket = null;\r\n    }\r\n  }\r\n  \r\n  getChatHistory(): Promise<ChatMessage[]> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.socket || !this.socket.connected) {\r\n        console.error('Socket not connected');\r\n        resolve([]); // Return empty array instead of rejecting for better UX\r\n        return;\r\n      }\r\n      \r\n      console.log('Requesting chat history for:', this.userId, this.sessionId);\r\n      \r\n      // Set a timeout in case the server doesn't respond\r\n      const historyTimeout = setTimeout(() => {\r\n        console.error('Chat history timeout');\r\n        resolve([]); // Return empty array on timeout\r\n      }, 8000);\r\n      \r\n      this.socket.emit('chat:history', {\r\n        userId: this.userId,\r\n        sessionId: this.sessionId\r\n      });\r\n      \r\n      this.socket.once('chat:history', (history: ChatMessage[]) => {\r\n        console.log('Received chat history:', history);\r\n        clearTimeout(historyTimeout);\r\n        \r\n        // Check if history is valid\r\n        if (!Array.isArray(history)) {\r\n          console.error('Invalid chat history format:', history);\r\n          resolve([]);\r\n          return;\r\n        }\r\n        \r\n        // Convert timestamps to Date objects\r\n        const processedHistory = history.map(msg => ({\r\n          ...msg,\r\n          timestamp: typeof msg.timestamp === 'string' ? new Date(msg.timestamp) : msg.timestamp\r\n        }));\r\n        resolve(processedHistory);\r\n      });\r\n      \r\n      this.socket.once('chat:error', (error) => {\r\n        console.error('Chat history error:', error);\r\n        clearTimeout(historyTimeout);\r\n        resolve([]); // Return empty array instead of rejecting\r\n      });\r\n    });\r\n  }\r\n  \r\n  // Check if socket is connected\r\n  isConnected(): boolean {\r\n    return this.socket?.connected || false;\r\n  }\r\n}\r\n\r\nexport default new SocketService();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}